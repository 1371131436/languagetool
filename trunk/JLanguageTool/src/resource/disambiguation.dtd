<!--
Disambiguation Rules DTD
AgnÃ¨s Souque, 2007

This DTD defines a format for disambiguation rules
-->

<!ENTITY % Languages "(en|de|pl|fr|es|it|nl|lt|uk|ru|cs|sl|sv|xx)">

<!ELEMENT rules (unification*|rule|rulegroup)*>
<!ATTLIST rules lang %Languages; #REQUIRED>

<!-- unification declarations -->
<!ELEMENT unification (equivalence)+>
<!-- unification feature ID -->
<!ATTLIST unification feature ID #REQUIRED>

<!-- equivalences between features -->
<!ELEMENT equivalence (token)>
<!ATTLIST equivalence type ID #REQUIRED>

<!-- Use the rulegroup element to group similar 'rule' elements
that should appear as a single rule to the user: -->
<!ELEMENT rulegroup (rule+)>
<!-- A unique ID for rulegroup: -->
<!ATTLIST rulegroup id ID #REQUIRED>
<!-- A short description of the words disambiguated by this rule: -->
<!ATTLIST rulegroup name CDATA #IMPLIED>

<!ELEMENT rule (pattern,disambig,example?,example?)>
<!-- A unique ID for this rule (not required if this rule is inside 
a rulegroup): -->
<!ATTLIST rule id ID #IMPLIED>
<!-- A short description displayed to the user in the configuration dialog: -->
<!ATTLIST rule name CDATA #IMPLIED>

<!ELEMENT pattern (token|and|unify)*>
<!-- The position of the ambiguous token in the pattern. 
mark_from="0" refers to the first token. Note: "mark" is 
used only for selecting a single token and excludes using
mark_from & mark_to -->
<!ATTLIST pattern mark CDATA #IMPLIED>

<!-- Position of a sequence to be disambiguated. These
attributes exclude the usage of "mark" --> 
<!ATTLIST pattern mark_from CDATA #IMPLIED>
<!ATTLIST pattern mark_to CDATA #IMPLIED>

<!-- Whether rules should match case-sensitively ('yes' means: 
"FOO" doesn't match "foo") -->
<!ATTLIST pattern case_sensitive (yes|no) #IMPLIED>


<!-- Enables logical AND between token elements. -->
<!ELEMENT and (token+)>

<!-- Enables unifying tokens -->
<!ELEMENT unify (and|token+)>
<!ATTLIST unify feature CDATA #REQUIRED>
<!ATTLIST unify type CDATA #IMPLIED>
<!-- Enables matching tokens that are not in agreement easily -->
<!ATTLIST unify negate (yes|no) "no">

<!-- token element - tokens matched by rules, could be specified as regular expressions,
regexp="yes"; postag contains any POS tags. POS tags can be specified as regular
expressions as well using postag_regexp="yes"
-->
<!ELEMENT token (#PCDATA|exception|match)*>
<!-- Is token a lemma that should be expanded? For example, "walk" would be
expanded to "walks", "walked" etc. before the rule matches if this is
set to 'yes': -->
<!ATTLIST token inflected (yes|no) "no">
<!-- Is token a regexp? -->
<!ATTLIST token regexp (yes|no) "no">
<!-- Is token negated? Set to 'yes' to make tokens match that didn't match 
before and vice versa:-->
<!ATTLIST token negate (yes|no) "no">
<!-- The part-of-speech tag of the token: -->
<!ATTLIST token postag CDATA #IMPLIED>
<!-- Whether the string in 'postag' is a regular expression: -->
<!ATTLIST token postag_regexp (yes|no) "no">
<!-- Whether the postag match should be negated: -->
<!ATTLIST token negate_pos (yes|no) "no">
<!-- Maximum number of tags to skip before the match is found: -->
<!ATTLIST token skip CDATA #IMPLIED>
<!-- Is the token preceded with a whitespace? -->
<!ATTLIST token spacebefore (yes|no) "no">


<!-- Exception element -->
<!ELEMENT exception (#PCDATA)>
<!-- Is exception a lemma? -->
<!ATTLIST exception inflected (yes|no) "no">
<!-- Is exception a regexp? -->
<!ATTLIST exception regexp (yes|no) "no">
<!-- Is exception negated? - instead of ^ in 0.8.2 -->
<!ATTLIST exception negate (yes|no) "no">
<!-- The part-of-speech tag of the token: -->
<!ATTLIST exception postag CDATA #IMPLIED>
<!-- Whether the string in 'postag' is a regular expression: -->
<!ATTLIST exception postag_regexp (yes|no) "no">
<!-- Whether the postag match should be negated: -->
<!ATTLIST exception negate_pos (yes|no|ignore) "ignore">
<!-- Is the exception token preceded with a whitespace? -->
<!ATTLIST exception spacebefore (yes|no|ignore) "ignore">

<!-- defines if the exception should apply to skipped tokens
i.e., the validity scope of the exception: -->
<!ATTLIST exception scope (current|next|previous) "current">

<!-- disambig is used to give the correct tag to the ambiguous word -->
<!ELEMENT disambig (match*|wd*)>
<!ATTLIST disambig postag CDATA #IMPLIED>
<!-- possible actions on tokens matched -->
<!ATTLIST disambig action (add|filter|remove|replace|unify) "replace">

<!-- Refers to matched elements of the pattern. Can be used in
suggestions and in references in the pattern. -->
<!ELEMENT match (#PCDATA)>
<!-- Number of the matched token. -->
<!ATTLIST match no CDATA #REQUIRED>
<!-- Target POS tag, i.e., part of speech tag of the 
token that should be generated based on a given matched token -->
<!ATTLIST match postag CDATA #IMPLIED>
<!-- Whether the string in 'postag' is a regular expression: -->
<!ATTLIST match postag_regexp (yes|no) "no">
<!-- Optional regular expression that specifies how the original
POS tag should be replaced in order to find a form. It is implied
that the original POS tag is defined by the 'postag' attribute.-->
<!ATTLIST match postag_replace CDATA #IMPLIED>
<!-- Optional regular expression that specifies parts in the token -->
<!ATTLIST match regexp_match CDATA #IMPLIED>
<!-- Optional regular expression that what how to replace the token -->
<!ATTLIST match regexp_replace CDATA #IMPLIED>
<!-- Optional attribute: how to change the case of the token: start with lower 
case, start with upper case, all letters upper case, all letters lower case -->
<!ATTLIST match case_conversion (startlower|startupper|allupper|alllower) #IMPLIED>

<!-- used to add new interpretations -->
<!ELEMENT wd (#PCDATA)>
<!-- Lemma (base form) of the word -->
<!ATTLIST wd lemma CDATA #IMPLIED>
<!-- POS tag of the word -->
<!ATTLIST wd pos CDATA #IMPLIED>

<!-- The examples are used for the unit test cases. An 'ambiguous'
example is supposed to be processed to get at least one of the forms specified 
as 'disambiguated' forms (but not all ambiguous forms).  -->
<!ELEMENT example (#PCDATA|marker)*>
<!-- used to specify the example that are processed and those
that shouldn't change at all --> 
<!ATTLIST example type (untouched|ambiguous) #REQUIRED>
<!-- used to specify ambiguous word forms in "word[lemma1/POS1,lemma2/POS2]" format. -->
<!ATTLIST example inputform CDATA #IMPLIED>
<!-- used to specify disambiguated word forms in "word[lemma1/POS1,lemma2/POS2]" format. -->
<!ATTLIST example outputform CDATA #IMPLIED>

<!-- marks the processed token in a sentence -->
<!ELEMENT marker (#PCDATA)>
