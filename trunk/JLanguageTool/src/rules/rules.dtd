<!--
Grammar Rules DTD
Daniel Naber (http://www.danielnaber.de), 2001-12-21, 2005-08-20

This DTD defines a format for 
 -grammar and typo rules
 -deprecated words

Note for grammar rules:

* At least one of the examples should be type="correct",
  at least one should be type="incorrect". This constraint 
  is not part of the DTD. All examples will be used
  for the test cases.
* It's often difficult to say if an error is a grammar error or
  'just' a typo, so we have no attribute for that.
-->

<!ENTITY % Languages "(en|de|pl|fr|es|it|nl|lt|uk|ru|cs|sl|sv|xx)">

<!ELEMENT rules (unification*,phrases?,category*)>
<!ATTLIST rules lang %Languages; #REQUIRED>


<!-- phrase definitions -->
<!ELEMENT unification (equivalence)+>
<!-- unification feature ID -->
<!ATTLIST unification feature ID #REQUIRED>

<!-- equivalences between features -->
<!ELEMENT equivalence (token)>
<!ATTLIST equivalence type ID #REQUIRED>

<!-- phrase definitions -->
<!ELEMENT phrases (phrase)*>

<!-- individual phrase definition -->
<!ELEMENT phrase (unify|and|token|includephrases)*>
<!ATTLIST phrase id ID #REQUIRED>

<!-- element that points to the defined phrase -->
<!ELEMENT phraseref EMPTY>
<!ATTLIST phraseref idref IDREF #REQUIRED>

<!-- OR operator for phrases -->
<!ELEMENT includephrases (phraseref)*>

<!-- Use the category element to groups rules/rulegroups: -->
<!ELEMENT category (rule|rulegroup)*>
<!-- Category name, e.g. 'Grammar', 'Spelling', 'Style' etc. -->
<!ATTLIST category name CDATA #REQUIRED>
<!-- Turns the category off or on by default -->
<!ATTLIST category default (off|on) #IMPLIED>

<!-- Use the rulegroup element to group similar 'rule' elements
that should appear as a single rule to the user: -->
<!ELEMENT rulegroup (message?,rule+)>
<!-- A unique ID for rulegroup: -->
<!ATTLIST rulegroup id ID #REQUIRED>
<!-- A short description of the error detected by this rule: -->
<!ATTLIST rulegroup name CDATA #IMPLIED>
<!-- Whether the rulegroup is switched by default off -->
<!ATTLIST rulegroup default (off|on) #IMPLIED>

<!ELEMENT rule (pattern,message,short?,example,example+)>
<!-- A unique ID for this rule (not required if this rule is inside 
a rulegroup): -->
<!ATTLIST rule id ID #IMPLIED>
<!-- A short description displayed to the user in the configuration dialog: -->
<!ATTLIST rule name CDATA #IMPLIED>
<!-- Whether the rule is switched by default off -->
<!ATTLIST rule default (off|on) #IMPLIED>

<!ELEMENT pattern (token|phraseref|and|unify)*>
<!-- Whether rules should match case-sensitively ('yes' means: 
"FOO" doesn't match "foo") -->
<!ATTLIST pattern case_sensitive (yes|no) #IMPLIED>
<!-- Where in the pattern should the error marker start, relative to the
first token of the rule. Default is mark_from="0" which means that the error
marker starts at the first token. mark_from="1" lets the marker start at the
second word etc: -->
<!ATTLIST pattern mark_from CDATA #IMPLIED>
<!-- Where in the pattern should the error marker end, relative to the
last token of the rule. Default is mark_to="0" which means that the error 
marker ends at the last token. mark_to="-1" lets the marker end one token
before the last token etc: -->
<!ATTLIST pattern mark_to CDATA #IMPLIED>

<!-- Enables logical AND between token elements. -->
<!ELEMENT and (token+)>

<!-- Enables unifying tokens -->
<!ELEMENT unify (and|token+)>
<!ATTLIST unify feature CDATA #REQUIRED>
<!ATTLIST unify type CDATA #IMPLIED>
<!-- Enables matching tokens that are not in agreement easily -->
<!ATTLIST unify negate (yes|no) "no">

<!-- token element - tokens matched by rules, could be specified as regular expressions,
regexp="yes"; postag contains any POS tags. POS tags can be specified as regular
expressions as well using postag_regexp="yes"
-->
<!ELEMENT token (#PCDATA|exception|match)*>
<!-- Is token a lemma that should be expanded? For example, "walk" would be
expanded to "walks", "walked" etc. before the rule matches if this is
set to 'yes': -->
<!ATTLIST token inflected (yes|no) "no">
<!-- Is token a regexp? -->
<!ATTLIST token regexp (yes|no) "no">
<!-- Is token negated? Set to 'yes' to make tokens match that didn't match 
before and vice versa:-->
<!ATTLIST token negate (yes|no) "no">
<!-- The part-of-speech tag of the token: -->
<!ATTLIST token postag CDATA #IMPLIED>
<!-- Whether the string in 'postag' is a regular expression: -->
<!ATTLIST token postag_regexp (yes|no) "no">
<!-- Whether the postag match should be negated: -->
<!ATTLIST token negate_pos (yes|no) "no">
<!-- Maximum number of tags to skip before the match is found: -->
<!ATTLIST token skip CDATA #IMPLIED>
<!-- Is the token preceded with a whitespace? -->
<!ATTLIST token spacebefore (yes|no|ignore) "ignore">
<!-- Spaces are important for matching, leave them alone: -->
<!ATTLIST token
 xml:space (preserve) #FIXED 'preserve'>


<!-- Exception element -->
<!ELEMENT exception (#PCDATA)>
<!-- Is exception a lemma? -->
<!ATTLIST exception inflected (yes|no) "no">
<!-- Is exception a regexp? -->
<!ATTLIST exception regexp (yes|no) "no">
<!-- Is exception negated? - instead of ^ in 0.8.2 -->
<!ATTLIST exception negate (yes|no) "no">
<!-- The part-of-speech tag of the token: -->
<!ATTLIST exception postag CDATA #IMPLIED>
<!-- Whether the string in 'postag' is a regular expression: -->
<!ATTLIST exception postag_regexp (yes|no) "no">
<!-- Whether the postag match should be negated: -->
<!ATTLIST exception negate_pos (yes|no) "no">
<!-- Is the exception token preceded with a whitespace? -->
<!ATTLIST exception spacebefore (yes|no|ignore) "ignore">


<!-- defines if the exception should apply to skipped tokens
i.e., the validity scope of the exception -->
<!ATTLIST exception scope (current|next|previous) "current">

<!-- Message shown to the user if a rule matches: -->
<!ELEMENT message (#PCDATA|suggestion|match)*>
<!-- Spaces are important for creating suggestions, leave them alone: -->
<!ATTLIST message
 xml:space (preserve) #FIXED 'preserve'>

<!-- short comment displayed in context menu: -->
<!ELEMENT short (#PCDATA)>

<!-- The examples are used for the unit test cases. An 'incorrect'
example is supposed to trigger an error message, in an 'correct'
example no error may be detected: -->
<!ELEMENT example (#PCDATA|marker)*>
<!-- 'triggers_error' may be used to add sentences that are known
to currently produce false alarms: -->
<!ATTLIST example type (correct|incorrect|triggers_error) #REQUIRED>
<!-- Used to explain 'triggers_error': -->
<!ATTLIST example reason CDATA #IMPLIED>
<!-- used to check if the suggested correction is correct; multiple
suggestions are joined with "|". -->
<!ATTLIST example correction CDATA #IMPLIED>
<!-- Spaces are important for testing suggestions, leave them alone: -->
<!ATTLIST example
 xml:space (preserve) #FIXED 'preserve'>

<!-- Put this around the error, i.e. the part of the text that should be
shown to the user as incorrect. This is used by the test cases to see
if the rule matches at the correct position. You can change the position
of the error marker using mark_from/mark_to (see above): -->
<!ELEMENT marker (#PCDATA)>

<!-- Suggested correction. This will be shown to the user as a possible
replacement of the text marked as an error. The test cases use this
text to replace the text between the 'marker' tags and then re-check
the text. The example with the incorrect text replace by this text
may not produde an error anymore, otherwise the test case fails: -->
<!ELEMENT suggestion (#PCDATA|match)*>

<!-- Refers to matched elements of the pattern. Can be used in
suggestions and in references in the pattern. -->
<!ELEMENT match (#PCDATA)>
<!-- Number of the matched token. -->
<!ATTLIST match no CDATA #REQUIRED>
<!-- Target POS tag, i.e., part of speech tag of the 
token that should be generated based on a given matched token -->
<!ATTLIST match postag CDATA #IMPLIED>
<!-- Whether the string in 'postag' is a regular expression: -->
<!ATTLIST match postag_regexp (yes|no) "no">
<!-- Optional regular expression that specifies how the original
POS tag should be replaced in order to find a form. It is implied
that the original POS tag is defined by the 'postag' attribute.-->
<!ATTLIST match postag_replace CDATA #IMPLIED>
<!-- Optional regular expression that specifies parts in the token -->
<!ATTLIST match regexp_match CDATA #IMPLIED>
<!-- Optional regular expression that specifies how to replace the token -->
<!ATTLIST match regexp_replace CDATA #IMPLIED>
<!-- Optional attribute: how to change the case of the token: start with lower 
case, start with upper case, all letters upper case, all letters lower case -->
<!ATTLIST match case_conversion (startlower|startupper|allupper|alllower) #IMPLIED>
<!-- Optional attribute: defines if the match element should 
format a matched part of speech tag. Makes sense only inside 
the token element for refering to previous POS tags -->
<!ATTLIST match setpos (yes|no) "no">